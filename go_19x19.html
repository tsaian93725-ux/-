<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>圍棋 19x19（加速版 AI）</title>
  <style>
    :root{--bg:#f4f0e6;--line:#8b6f4e}
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{background:var(--bg);display:flex;align-items:flex-start;justify-content:center;padding:18px}
    .app{display:flex;gap:18px}
    .board-wrap{background:#fbf7ee;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.08)}
    canvas{display:block;background:linear-gradient(#f6e9c9,#f3dba1);border-radius:6px}
    .controls{width:320px}
    .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 4px 14px rgba(0,0,0,.06);margin-bottom:12px}
    .row{display:flex;gap:8px;align-items:center}
    button{padding:8px 10px;border-radius:6px;border:1px solid #ddd;background:#fff;cursor:pointer}
    select,input[type=number]{padding:6px;border-radius:6px;border:1px solid #ddd}
    .status{font-weight:600;margin-top:8px}
    small{color:#666}
  </style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <canvas id="board" width="760" height="760"></canvas>
    </div>
    <div class="controls">
      <div class="panel">
        <div class="row"><label>先手（黑）：</label><select id="playerBlack"><option value="human">人</option><option value="ai">AI</option></select></div>
        <div class="row" style="margin-top:8px"><label>後手（白）：</label><select id="playerWhite"><option value="human">人</option><option value="ai" selected>AI</option></select></div>
        <div class="row" style="margin-top:8px"><label>AI 強度：</label><select id="aiLevel"><option value="1">快（弱）</option><option value="2">中</option><option value="3" selected>強（稍慢）</option></select></div>
        <div class="row" style="margin-top:12px"><button id="newBtn">新局</button><button id="passBtn">過</button><button id="undoBtn">悔棋</button></div>
        <div class="status" id="status">載入完成 — 請開始下棋</div>
        <small>此版本為加速版 AI，採用減少候選與簡化模擬的輕量蒙地卡羅法，速度約提升 3~5 倍。</small>
      </div>
    </div>
  </div>

<script>
const SIZE = 19;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const edge = 40;
const w = canvas.width - edge*2;
const cell = w/(SIZE-1);
let board, turn, history, previousBoard;
let statusEl = document.getElementById('status');

function emptyBoard(){return Array.from({length:SIZE},()=>Array(SIZE).fill(0));}
function copyBoard(b){return b.map(r=>r.slice());}

function render(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 ctx.strokeStyle='#8b6f4e'; ctx.lineWidth=1.2;
 for(let i=0;i<SIZE;i++){
  const x=edge+i*cell, y=edge+i*cell;
  ctx.beginPath();ctx.moveTo(x,edge);ctx.lineTo(x,edge+(SIZE-1)*cell);ctx.stroke();
  ctx.beginPath();ctx.moveTo(edge,y);ctx.lineTo(edge+(SIZE-1)*cell,y);ctx.stroke();
 }
 const star=[3,9,15]; ctx.fillStyle='#8b6f4e';
 for(let r of star)for(let c of star){ctx.beginPath();ctx.arc(edge+c*cell,edge+r*cell,4,0,Math.PI*2);ctx.fill();}
 for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){
  const v=board[r][c]; if(!v)continue;
  const x=edge+c*cell, y=edge+r*cell;
  ctx.beginPath();ctx.arc(x,y,cell*0.44,0,Math.PI*2);
  ctx.fillStyle=(v===1)?'#111':'#fff';ctx.fill();ctx.strokeStyle='#333';ctx.stroke();
 }
}

const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
function inside(r,c){return r>=0&&r<SIZE&&c>=0&&c<SIZE;}
function floodGroup(b,r,c){const color=b[r][c];if(!color)return{stones:[],lib:new Set()};const st=[[r,c]],seen=new Set([r+','+c]);const stones=[];let lib=new Set();while(st.length){const[rr,cc]=st.pop();stones.push([rr,cc]);for(let[dr,dc]of dirs){const nr=rr+dr,nc=cc+dc;if(!inside(nr,nc))continue;if(b[nr][nc]===0)lib.add(nr+','+nc);else if(b[nr][nc]===color&&!seen.has(nr+','+nc)){seen.add(nr+','+nc);st.push([nr,nc]);}}}return{stones,lib};}
function isLegalMove(b,r,c,color){if(b[r][c]!==0)return false;const nb=copyBoard(b);nb[r][c]=color;const enemy=3-color;for(let[dr,dc]of dirs){const nr=r+dr,nc=c+dc;if(inside(nr,nc)&&nb[nr][nc]===enemy){const g=floodGroup(nb,nr,nc);if(g.lib.size===0)for(let[sr,sc]of g.stones)nb[sr][sc]=0;}}const g2=floodGroup(nb,r,c);if(g2.lib.size===0)return false;return true;}
function playMove(b,r,c,color){if(!isLegalMove(b,r,c,color))return false;const nb=copyBoard(b);nb[r][c]=color;const enemy=3-color;for(let[dr,dc]of dirs){const nr=r+dr,nc=c+dc;if(inside(nr,nc)&&nb[nr][nc]===enemy){const g=floodGroup(nb,nr,nc);if(g.lib.size===0)for(let[sr,sc]of g.stones)nb[sr][sc]=0;}}previousBoard=copyBoard(b);return nb;}

function legalMovesList(b,color){const moves=[];for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++)if(isLegalMove(b,r,c,color))moves.push([r,c]);return moves;}
function computeScore(b){let black=0,white=0;for(let r=0;r<SIZE;r++)for(let c=0;c<SIZE;c++){if(b[r][c]===1)black++;else if(b[r][c]===2)white++;}return{black,white};}

canvas.addEventListener('click',ev=>{const rect=canvas.getBoundingClientRect();const x=ev.clientX-rect.left,y=ev.clientY-rect.top;const c=Math.round((x-edge)/cell),r=Math.round((y-edge)/cell);if(!inside(r,c))return;makeHumanMove(r,c);});
function makeHumanMove(r,c){const p=(turn===1?playerBlack:playerWhite).value;if(p!=='human')return;attemptMove(r,c);}
function attemptMove(r,c){const nb=playMove(board,r,c,turn);if(!nb){statusEl.textContent='不可落子';return;}history.push({board:copyBoard(board),turn});board=nb;turn=3-turn;render();statusEl.textContent=(turn===1?'黑':'白')+' 的回合';setTimeout(()=>maybeAIMove(),30);}

function passTurn(){history.push({board:copyBoard(board),turn});turn=3-turn;statusEl.textContent=(turn===1?'黑':'白')+' 過';setTimeout(()=>maybeAIMove(),30);}
function undo(){if(history.length===0)return;const last=history.pop();board=copyBoard(last.board);turn=last.turn;render();}
function reset(){board=emptyBoard();turn=1;history=[];previousBoard=null;statusEl.textContent='新局開始 — 黑先';render();}

document.getElementById('newBtn').onclick=reset;
document.getElementById('passBtn').onclick=passTurn;
document.getElementById('undoBtn').onclick=undo;

async function aiChooseMove(color){const level=parseInt(document.getElementById('aiLevel').value);const moves=legalMovesList(board,color);if(moves.length===0)return null;const sample=Math.min(moves.length,15+level*5);const chosen=[];while(chosen.length<sample){const i=Math.floor(Math.random()*moves.length);if(!chosen.includes(i))chosen.push(i);}let best=null,bestScore=-1;for(let idx of chosen){const [r,c]=moves[idx];let win=0,tests=level*2+2;for(let k=0;k<tests;k++){const sim=playMove(copyBoard(board),r,c,color);if(!sim)continue;const sc=computeScore(sim);if((color===1&&sc.black>=sc.white)||(color===2&&sc.white>=sc.black))win++;}if(win>bestScore){bestScore=win;best=[r,c];}}return best;}

async function maybeAIMove(){const player=(turn===1?playerBlack:playerWhite).value;if(player!=='ai')return;statusEl.textContent=(turn===1?'黑':'白')+' AI 思考中...';await new Promise(r=>setTimeout(r,20));const move=await aiChooseMove(turn);if(!move){passTurn();return;}const nb=playMove(board,move[0],move[1],turn);if(nb){history.push({board:copyBoard(board),turn});board=nb;turn=3-turn;render();}statusEl.textContent=(turn===1?'黑':'白')+' 的回合';setTimeout(()=>maybeAIMove(),60);}

reset();render();setTimeout(()=>maybeAIMove(),100);
</script>
</body>
</html>
